#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <RF24.h>
#include <EEPROM.h>

// --- CABLAGE ---
#define PIN_ENC_A    3   // Encodeur pin A
#define PIN_ENC_B    4   // Encodeur pin B
#define PIN_ENC_BTN  2   // Bouton de l'encodeur
#define PIN_SW3      A6  // Bouton additionnel
#define PIN_LED_R    5   // LED Rouge
#define PIN_LED_G    6   // LED Verte
#define PIN_LED_B    9   // LED Bleue
#define PIN_BUZZER   10
#define PIN_CE       7   // Radio CE
#define PIN_CSN      8   // Radio CSN

// --- EEPROM (Mémoire interne) ---
#define EEPROM_PSEUDO    0
#define EEPROM_CHANNEL   16
#define EEPROM_SOUND     17

// --- INIT MATERIEL ---
RF24 radio(PIN_CE, PIN_CSN);
Adafruit_SSD1306 display(128, 64, &Wire, -1);

// --- STRUCTURES DONNEES ---
// Pour gérer les couleurs de LED facilement
enum Priority : uint8_t {
  NORMAL = 0,
  FAVORI = 1,
  URGENT = 2
};

// Structure du message radio (le NRF24 est limité à 32 octets max)
struct MessagePacket {
  uint8_t packetNum;    // Numéro du paquet (ex: 1 sur 3)
  uint8_t totalPackets; // Nombre total de paquets
  Priority priority;    // Priorité (pour la couleur LED)
  char sender[12];      // Pseudo
  char data[16];        // Le bout de message (16 char max)
};

// --- CLAVIER (Stocké en Flash pour gagner de la RAM) ---
const char PROGMEM charset_page1[] = "abcdefghijklmnopqrstuvwxyz0123456789 !?"; 
const char PROGMEM charset_page2[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !?"; 
const char PROGMEM charset_settings[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 !?.,;:";

// --- VARIABLES ---
char myPseudo[12] = "";
uint8_t radioChannel = 100; // Canal par défaut
uint8_t soundType = 0;      // 0: Normal, 1: Discret, 2: Fort

// Etats du système
bool inMenuMode = true;
int mainMenuSelection = 0;
bool isSenderMode = false;

// Gestion Encodeur
volatile int encoderDelta = 0; // 'volatile' car modifié par interruption

// Gestion Message
char messageBuffer[101]; // On stocke le message entier ici
int msgIndex = 0;
int charIndex = 0;
uint8_t currentPage = 0; // 0 = minuscule, 1 = majuscule

// Timers et Bips
bool alertActive = false;
bool alertWasStopped = false;
unsigned long alertStartTime = 0;
unsigned long lastBeepTime = 0;
unsigned long sw3PressStartTime = 0;
bool sw3IsPressed = false;
unsigned long encBtnPressStartTime = 0;
bool encBtnIsPressed = false;

// Buffer réception
char receivedMessage[101] = "";
char receivedSender[12] = "";
Priority receivedPriority = NORMAL;
bool messageComplete = false;
uint8_t receivedPackets = 0;

// --- DECLARATIONS ---
void runMenuLoop();
void setupSenderMode();
void setupReceiverMode();
void runReceiverLoop();
void runSenderLoop();
void selectPriorityMode();
void handleSenderButtons();
void checkReturnMenu();
void typeCharacter();
void deleteCharacter();
void sendMessageWithPriority(Priority prio);
void drawSenderInterface();
void runSettingsMenu();
void configurePseudo();
void configureChannel();
void configureSound();
void loadSettings();
void saveSettings();
void manageActiveAlert();
void setLEDColor(Priority prio);
void stopAlert();
void isrEncoder();
int getEncoderTurn();
char getCharFromPage(uint8_t page, int index);
int getPageSize(uint8_t page);

// --- SETUP ---
void setup() {
  pinMode(PIN_ENC_A, INPUT_PULLUP);
  pinMode(PIN_ENC_B, INPUT_PULLUP);
  pinMode(PIN_ENC_BTN, INPUT_PULLUP);
  pinMode(PIN_LED_R, OUTPUT);
  pinMode(PIN_LED_G, OUTPUT);
  pinMode(PIN_LED_B, OUTPUT);
  pinMode(PIN_BUZZER, OUTPUT);
  digitalWrite(PIN_BUZZER, LOW);

  // Interruption pour ne pas rater les crans de l'encodeur
  attachInterrupt(digitalPinToInterrupt(PIN_ENC_A), isrEncoder, CHANGE);

  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    for(;;); // Plante si pas d'écran
  }

  loadSettings(); // Récupère la config sauvegardée

  const uint8_t address[] = {0x11, 0x11, 0x11, 0x11, 0x11};

  if (!radio.begin()) {
    display.clearDisplay();
    display.println(F("Radio Fail!"));
    display.display();
    while(1);
  }

  // Config Radio pour la portée
  radio.setPALevel(RF24_PA_LOW);
  radio.setDataRate(RF24_250KBPS); // Débit lent = meilleure portée
  radio.setChannel(radioChannel);
  radio.openReadingPipe(1, address);
  radio.openWritingPipe(address);
}

// --- GESTION ENCODEUR ---
void isrEncoder() {
  // Appelé automatiquement quand on tourne le bouton
  int stateA = digitalRead(PIN_ENC_A);
  int stateB = digitalRead(PIN_ENC_B);
  if (stateA == stateB) encoderDelta--;
  else encoderDelta++;
}

int getEncoderTurn() {
  noInterrupts(); // Pause les interruptions pour lire la valeur proprement
  int val = encoderDelta;
  encoderDelta = 0;
  interrupts();
  return val;
}

// --- OUTILS TEXTE ---
// Lit les caractères dans la mémoire programme (Flash)
char getCharFromPage(uint8_t page, int index) {
  if (page == 0) return pgm_read_byte(&charset_page1[index]);
  else return pgm_read_byte(&charset_page2[index]);
}

int getPageSize(uint8_t page) {
  return 40;
}

// --- BOUCLE PRINCIPALE ---
void loop() {
  // Redirection vers la bonne boucle selon le mode
  if (inMenuMode) runMenuLoop();
  else if (isSenderMode) runSenderLoop();
  else runReceiverLoop();
}

// ==================================================
// MENU PRINCIPAL
// ==================================================
void runMenuLoop() {
  mainMenuSelection = 0;
  bool selected = false;
  display.clearDisplay();
  display.setTextColor(WHITE);
  display.setTextSize(1);
  getEncoderTurn();
  radio.startListening(); // On écoute toujours, même dans le menu

  while (!selected) {
    // Vérif si message reçu en arrière-plan
    if (radio.available()) {
      MessagePacket packet;
      radio.read(&packet, sizeof(packet));

      if (packet.packetNum == 0) {
        // Nouveau message : on reset le buffer
        memset(receivedMessage, 0, sizeof(receivedMessage));
        strncpy(receivedSender, packet.sender, 11);
        receivedPriority = packet.priority;
        receivedPackets = 0;
      }
      
      // On colle le bout de message reçu à la suite
      int currentLen = strlen(receivedMessage);
      int bytesToCopy = 16;
      if (packet.packetNum == packet.totalPackets - 1) {
        bytesToCopy = strlen(packet.data);
      }
      
      for (int i = 0; i < bytesToCopy; i++) {
        receivedMessage[currentLen + i] = packet.data[i];
      }
      receivedMessage[currentLen + bytesToCopy] = '\0';
      receivedPackets++;

      // Message complet ? On affiche l'alerte
      if (receivedPackets >= packet.totalPackets) {
        messageComplete = true;
        alertActive = true;
        alertStartTime = millis();
        setLEDColor(receivedPriority);
        isSenderMode = false;
        radio.startListening();
        inMenuMode = false; // On force la sortie du menu
        return;
      }
    }

    if (alertActive) manageActiveAlert();

    // Navigation encodeur
    int turn = getEncoderTurn();
    if (turn != 0) {
      if (turn > 0) mainMenuSelection++;
      else mainMenuSelection--;
      if (mainMenuSelection > 2) mainMenuSelection = 0;
      if (mainMenuSelection < 0) mainMenuSelection = 2;
    }

    // Validation
    if (digitalRead(PIN_ENC_BTN) == LOW) {
      delay(50);
      if (digitalRead(PIN_ENC_BTN) == LOW) {
        selected = true;
        tone(PIN_BUZZER, 1000, 100);
        delay(300);
        if (mainMenuSelection == 0) setupReceiverMode();
        else if (mainMenuSelection == 1) setupSenderMode();
        else runSettingsMenu();
        inMenuMode = false;
      }
    }

    // Affichage Menu
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println(F("== MENU PRINCIPAL =="));
    display.setCursor(0, 15);
    display.print(mainMenuSelection == 0 ? F("> ") : F("  "));
    display.println(F("RECEVOIR (DEFAUT)"));
    // ... suite affichage ...
    display.setCursor(0, 30);
    display.print(mainMenuSelection == 1 ? F("> ") : F("  "));
    display.println(F("ENVOYER"));
    display.setCursor(0, 45);
    display.print(mainMenuSelection == 2 ? F("> ") : F("  "));
    display.println(F("PARAMETRES"));
    display.display();
  }
}

// ==================================================
// PARAMETRES
// ==================================================
void runSettingsMenu() {
  // Même logique que le menu principal
  // Permet de changer Pseudo, Canal et Son
  // ...
  int settingChoice = 0;
  bool done = false;
  getEncoderTurn();

  while (!done) {
     // Navigation
    int turn = getEncoderTurn();
    if (turn != 0) {
      if (turn > 0) settingChoice++; else settingChoice--;
      if (settingChoice > 3) settingChoice = 0;
      if (settingChoice < 0) settingChoice = 3;
    }

    // Validation
    if (digitalRead(PIN_ENC_BTN) == LOW) {
      delay(50);
      if (digitalRead(PIN_ENC_BTN) == LOW) {
        tone(PIN_BUZZER, 1000, 50);
        delay(300);
        if (settingChoice == 0) configurePseudo();
        else if (settingChoice == 1) configureChannel();
        else if (settingChoice == 2) configureSound();
        else { done = true; inMenuMode = true; }
      }
    }
    
    // Affichage
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println(F("=== PARAMETRES ==="));
    display.setCursor(0, 15);
    display.print(settingChoice == 0 ? F("> ") : F("  "));
    display.print(F("Pseudo: ")); display.println(myPseudo);
    display.setCursor(0, 30);
    display.print(settingChoice == 1 ? F("> ") : F("  "));
    display.print(F("Canal: ")); display.println(radioChannel);
    display.setCursor(0, 45);
    display.print(settingChoice == 2 ? F("> ") : F("  "));
    display.print(F("Son: ")); display.println(soundType);
    display.setCursor(0, 56);
    display.print(settingChoice == 3 ? F("> ") : F("  "));
    display.println(F("RETOUR"));
    display.display();
  }
}

void configurePseudo() {
  // Saisie caractère par caractère (comme pour les SMS)
  // Sauvegarde auto à la fin
}

void configureChannel() {
  // Changement de fréquence radio
  // Important : sauvegarde dans EEPROM
}

void configureSound() {
  // Choix du profil sonore
}

void loadSettings() {
  // Lecture de l'EEPROM au démarrage
  EEPROM.get(EEPROM_PSEUDO, myPseudo);
  radioChannel = EEPROM.read(EEPROM_CHANNEL);
  soundType = EEPROM.read(EEPROM_SOUND);

  // Valeurs par défaut si EEPROM vide
  if (radioChannel == 255 || radioChannel > 125) radioChannel = 100;
  if (soundType > 2) soundType = 0;
  if (myPseudo[0] == 255) myPseudo[0]='\0';
}

void saveSettings() {
  // Ecriture dans l'EEPROM (pour garder les infos après extinction)
  EEPROM.put(EEPROM_PSEUDO, myPseudo);
  EEPROM.write(EEPROM_CHANNEL, radioChannel);
  EEPROM.write(EEPROM_SOUND, soundType);
}

// ==================================================
// MODE ENVOYEUR
// ==================================================
void setupSenderMode() {
  isSenderMode = true;
  radio.stopListening(); // On doit arrêter d'écouter pour pouvoir parler
  memset(messageBuffer, 0, sizeof(messageBuffer));
  msgIndex = 0;
  charIndex = 0;
  currentPage = 0;
}

void runSenderLoop() {
  // Gestion clavier virtuel
  int turn = getEncoderTurn();
  if (turn != 0) {
    if (turn > 0) charIndex++;
    else charIndex--;
    // ...
  }

  handleSenderButtons();
  drawSenderInterface();
}

void handleSenderButtons() {
  // Gestion des appuis courts/longs sur SW3
  int sw3Val = analogRead(PIN_SW3);
  bool sw3State = (sw3Val < 500);

  if (sw3State && !sw3IsPressed) {
    sw3IsPressed = true;
    sw3PressStartTime = millis();
    tone(PIN_BUZZER, 4000, 20); // Petit bruit touches
  }
  else if (!sw3State && sw3IsPressed) {
    sw3IsPressed = false;
    unsigned long duration = millis() - sw3PressStartTime;
    if (duration > 800) {
      if (msgIndex > 0) selectPriorityMode(); // Appui long -> Envoyer
    }
    else if (duration > 50) typeCharacter(); // Appui court -> Ecrire
  }

  checkReturnMenu();
}

void typeCharacter() {
  // Ajoute la lettre sélectionnée au message
}

void deleteCharacter() {
  // Efface la dernière lettre
  if (msgIndex > 0) {
    msgIndex--;
    messageBuffer[msgIndex] = '\0';
    tone(PIN_BUZZER, 3000, 20);
  }
}

void checkReturnMenu() {
  // Vérifie si on veut quitter (appui long encodeur)
}

// ==================================================
// ENVOI RADIO
// ==================================================
void selectPriorityMode() {
  // Choix de l'urgence (Vert, Jaune, Rouge)
}

void sendMessageWithPriority(Priority prio) {
  display.clearDisplay();
  display.println(F("ENVOI..."));
  display.display();

  int msgLen = strlen(messageBuffer);
  // Calcul du nombre de paquets nécessaires
  int totalPackets = (msgLen + 15) / 16;

  MessagePacket packet;
  packet.priority = prio;
  packet.totalPackets = totalPackets;
  strncpy(packet.sender, myPseudo, 11);

  bool allOk = true;

  // On découpe le message et on envoie les morceaux
  for (int i = 0; i < totalPackets; i++) {
    packet.packetNum = i;
    int start = i * 16;
    int len = min(16, msgLen - start);
    
    memset(packet.data, 0, 16);
    strncpy(packet.data, messageBuffer + start, len);

    radio.stopListening();
    bool ok = radio.write(&packet, sizeof(packet));
    if (!ok) allOk = false;
    
    // Petite pause pour laisser le temps au récepteur de traiter
    delay(100); 
  }

  if (allOk) {
    tone(PIN_BUZZER, 1000, 100); // Succès
    msgIndex = 0;
    messageBuffer[0] = '\0';
  } else {
    tone(PIN_BUZZER, 200, 500); // Erreur
  }
  delay(1000);
}

void drawSenderInterface() {
  // Affiche le message en cours et le clavier
}

// ==================================================
// MODE RECEVEUR
// ==================================================
void setupReceiverMode() {
  isSenderMode = false;
  radio.startListening(); // Mode écoute
  memset(receivedMessage, 0, sizeof(receivedMessage));
  receivedPackets = 0;
  messageComplete = false;
  stopAlert(); 
}

void runReceiverLoop() {
  checkReturnMenu();

  // Bouton pour arrêter l'alarme ou effacer le message
  int sw3Val = analogRead(PIN_SW3);
  if (sw3Val < 500) {
    // ...
  }

  if (alertActive) manageActiveAlert();

  // Lecture radio
  if (radio.available()) {
    MessagePacket packet;
    radio.read(&packet, sizeof(packet));

    // Si c'est le début d'un nouveau message
    if (packet.packetNum == 0) {
      memset(receivedMessage, 0, sizeof(receivedMessage));
      strncpy(receivedSender, packet.sender, 11);
      // ...
    }

    // ... Reconstruction du message ...
  }

  // Affichage du message
  if (messageComplete) {
    // ... Affichage expéditeur et texte ...
  }
  else {
    display.clearDisplay();
    display.println(F("En attente..."));
    display.display();
  }
}

// ==================================================
// GESTION LEDS ET SON
// ==================================================
void setLEDColor(Priority prio) {
  // Reset
  digitalWrite(PIN_LED_R, LOW); 
  digitalWrite(PIN_LED_G, LOW); 
  digitalWrite(PIN_LED_B, LOW);
  
  // Couleur selon priorité
  switch(prio) {
    case URGENT: digitalWrite(PIN_LED_R, HIGH); break;
    case FAVORI: digitalWrite(PIN_LED_R, HIGH); digitalWrite(PIN_LED_G, HIGH); break;
    case NORMAL: digitalWrite(PIN_LED_G, HIGH); break;
  }
}

void manageActiveAlert() {
  // Fait bipper le buzzer sans bloquer le code (millis)
  unsigned long currentMillis = millis();
  // ...
}

void stopAlert() {
  alertActive = false;
  // On éteint tout
  digitalWrite(PIN_LED_R, LOW);
  digitalWrite(PIN_LED_G, LOW);
  digitalWrite(PIN_LED_B, LOW);
  noTone(PIN_BUZZER);
}